# Dead code

```
        # 引き分けを１局と数えると、シリーズの中で点数が足らず、決着が付かず、シリーズ全体としての引き分けが増えるので、対応が必要です
        #
        # # # NOTE ルールとして、引き分けを廃止することはできるか？ ----> 両者の実力が等しく、先手後手の有利も等しいとき、真の結果は引き分けがふさわしい。引き分けを消すことはできない
        # # #
        # # # NOTE その場合、先手勝利でいいのでは？ ----> 引き分け率１０％のとき、先手にしろ後手にしろ、そっちの勝率が５％上がってしまった。［目標の点数］を２倍にしてもだいたい同じ
        # # # NOTE 点数が引き分けということは、［上限対局数］を全部引き分けだったということです。引き分けが先手勝ちとか、後手勝ちと決めてしまうと、対局数が１のとき、影響がもろに出てしまう
        # # # NOTE 点数が引き分けのとき、最後に勝った方の勝ちとすればどうなる？ ----> 先手の方が勝つ機会が多いのでは？
        # # # NOTE 引き分けは［両者得点］にしたらどうか？ ----> step を足すのは裏番に有利すぎる。１点を足すのは数学的に意味がない。
        # # # NOTE 引き分けは［両者得点］にし、かつ、引き分けが奇数回なら後手勝ち、偶数回なら先手勝ちにしたらどうか？ ----> 対局数が１のときの影響がでかい
        # # # NOTE 引き分けは、［表勝ち１つの点数］が小さい表番の方に大きく響く？
        # # # NOTE 引き分けは減らせるが、ゼロにはできない、という感じ
        # NOTE タイブレークは、［将棋の引分け率］が上がってきたとき調整が困難。当然、引き分け率が上がるほど裏有利になる


#
#   NOTE 手番を交代する場合、［最大ｎ本勝負］は、（Ａさんの［表だけでの反復実施数］－１）＋（Ａさんの［裏だけでの反復実施数］－１）＋（Ｂさんの［表だけでの反復実施数］－１）＋（Ｂさんの［裏だけでの反復実施数］－１）＋１ になる
#


        #   交互に手番を替えるか、変えないかに関わらず、先手と後手の重要さは p で決まっている。
        #
        #   ［表勝ちだけでの対局数］も、
        #   ［裏勝ちだけでの対局数］数も、 p で決まっている。
        #
        #   ひとまず、リーチしている状況を考えてみよう。
        #
        #   'Ｘ' を、Ａさん（またはＢさん）の［表勝ちだけでの対局数］、
        #   'ｘ' を、Ａさん（またはＢさん）の［裏勝ちだけでの対局数］とする。
        #
        #   リーチしている状況は下の式のようになる。
        #
        #       ２（Ｘ－１）＋２（ｘー１）
        #
        #   ここに、点数の最小単位である　ｘ　を足して、
        #
        #       ２（Ｘ－１）＋２（ｘー１）＋ｘ
        #
        #   としたものが、［上限対局数］だ。
        #
        #
        #   仮に、Ｘ＝１、ｘ＝１　を式に入れてみる。
        #
        #       ２（１－１）＋２（１ー１）＋１　＝　１
        #
        #   対局数は１と分かる。
        #
        #
        #   ・　Ｘ＝１、ｘ＝１ ----> 上限対局数　１
        #   ・　Ｘ＝２、ｘ＝１ ----> 上限対局数　３
        #   ・　Ｘ＝３、ｘ＝１ ----> 上限対局数　５
        #   ・　Ｘ＝３、ｘ＝２ ----> 上限対局数　７
        #   ・　Ｘ＝４、ｘ＝１ ----> 上限対局数　７
        #   ・　Ｘ＝４、ｘ＝２ ----> 上限対局数　９
        #   ・　Ｘ＝４、ｘ＝３ ----> 上限対局数１１
        #
        #   上限対局数は奇数になるようだ。
        #
        #
        #   'Ａ' を、Ａさんの先手一本、'ａ' を、Ａさんの後手一本、
        #   'Ｂ' を、Ｂさんの先手一本、'ｂ' を、Ｂさんの後手一本とする。
        #
        #
        #   Ｘ＝１、ｘ＝１　上限対局数が１のケースの全パターンを見てみよう
        #
        #   (1) Ａ （先） ----> Ａさんの勝ち
        #   (2) ｂ （後） ----> Ｂさんの勝ち
        #
        #   これだと、Ｂさんは後手しか持てなくて厳しそうだ。 p=0.5 ぐらいの、五分五分ということか？
        #
        #
        #   Ｘ＝２、ｘ＝１　上限対局数が３のケースの全パターンを見てみよう
        #
        #                                           通分 先手は 1 点、後手は 2 点
        #                                           ----------------------------
        #   (1) ＡＢＡ（先先先） ----> Ａさんの勝ち     Ａさん 2 点、Ｂさん 1 点
        #   (2) ＡＢｂ（先先後） ----> Ｂさんの勝ち     Ａさん 1 点、Ｂさん 3 点
        #   (3) Ａａ　（先後　） ----> Ａさんの勝ち     Ａさん 3 点
        #   (4) ｂ　　（後　　） ----> Ｂさんの勝ち     Ｂさん 2 点
        #
        #   Ａさんは先手２回で勝てるのに対し、Ｂさんは後手を含めないと勝てない。
        #
        #   NOTE なんか先手のＡさんが有利なような気がするが、コイン投げ試行をしてみると、印象とはべつに成績としてバランスはとれているようだ？
        #
        #   思考：
        #       以下、偶数対局毎に手番を交代するとしたときの、Ｘ＝２、ｘ＝１　３本勝負のケースの全パターン
        #       
        #       (1) ＡＢＢ（先先先） ----> Ｂさんの勝ち
        #       (2) ＡＢａ（先先後） ----> Ａさんの勝ち
        #       (3) Ａａ　（先後　） ----> Ａさんの勝ち
        #       (4) ｂ　　（後　　） ----> Ｂさんの勝ち
        #       
        #       Ｂさんは先手２回で勝てるのに対し、Ａさんは後手を含めないと勝てない。
        #   
        #   
        #   期待勝利機会という考え方。先手一本も後手一本も 0.5。
        #   後手が２回回ってくるのも、２局１セットで考えれば普通。
        #   先手が先にＡさんに回ってきて、そこで２局１セットでないのが不満感？
        #   第３局で終わりにせず、第４局の消化試合までやるべき？ そしたら引き分けが生まれるのでは？ 引き分けにする権利？
        #
        #   NOTE ［先後固定制］と［先後交互制］で、引き分けにならないかどうかは、変わるだろうか？
        #
        #   FIXME 合ってるか、あとで確認
        #


#   * Ａさんが勝つために必要な［表勝ちだけでの対局数］
#   * Ａさんが勝つために必要な［裏勝ちだけでの対局数］
#   * Ａさんが勝つために必要な［表裏の回数の合算］
#   * Ｂさんが勝つために必要な［表勝ちだけでの対局数］
#   * Ｂさんが勝つために必要な［裏勝ちだけでの対局数］
#   * Ｂさんが勝つために必要な［表裏の回数の合算］
```


```
    # ファイルが存在せず、空データフレームが新規作成されたら
    if is_new:

        # ループカウンター
        span = 1        # ［目標の点数］
        t_step = 1      # ［後手で勝ったときの勝ち点］
        h_step = 1      # ［先手で勝ったときの勝ち点］

        print(f"[{datetime.datetime.now()}][{depth=}  turn_system={turn_system_name:11}  p={spec.p:.2f}  failure_rate={spec.failure_rate:.2f}] NEW_FILE")

        # １件も処理してないが、ファイルを保存したいのでフラグを立てる
        number_of_dirty += 1

    # ファイルが存在して、読み込まれたなら
    else:
        # ループカウンター
        if len(df) < 1:
            span = 1        # ［目標の点数］
            t_step = 1      # ［後手で勝ったときの勝ち点］
            h_step = 1      # ［先手で勝ったときの勝ち点］

        else:
            # 途中まで処理が終わってるんだったら、途中から再開したいが。ループの途中から始められるか？

            # TODO 最後に処理された span は？
            span = int(df['span'].max())

            # TODO 最後に処理された span のうち、最後に処理された t_step は？
            t_step = int(df.loc[df['span']==span, 't_step'].max())

            # TODO 最後に処理された span, t_step のうち、最後に処理された h_step は？
            h_step = int(df.loc[(df['span']==span) & (df['t_step']==t_step), 'h_step'].max())

            print(f"[{datetime.datetime.now()}][{depth=}  turn_system={turn_system_name:11}  p={p:.2f}  failure_rate={spec.failure_rate:.2f}] RESTART_ {span=:2}  {t_step=:2}  {h_step=:2}")
```

```
    while span < OUT_OF_UPPER_SPAN + 1:

        calculation_status = automatic_in_loop(
                df=df,
                spec=spec,
                span=span,
                t_step=t_step,
                h_step=h_step,
                depth=depth)

        if calculation_status in [TERMINATED, YIELD]:
            return df, calculation_status, span

        # カウントアップ
        h_step += 1
        if t_step < h_step:
            h_step = 1
            t_step += 1
            if span < t_step:
                t_step = 1
                span += 1
```


```
                        # # 理論値の場合
                        # elif self._generation_algorythm == THEORETICAL:

                        #     # オーバーフロー例外に対応したプログラミングをすること
                        #     latest_p, err = calculate_probability(
                        #             p=spec.p,
                        #             H=latest_series_rule.step_table.get_time_by(challenged=SUCCESSFUL, face_of_coin=HEAD),
                        #             T=latest_series_rule.step_table.get_time_by(challenged=SUCCESSFUL, face_of_coin=TAIL))
                            
                        #     # FIXME とりあえず、エラーが起こっている場合は、あり得ない値をセットして計算を完了させておく
                        #     if err is not None:
                        #         latest_p_error = 0      # 何度計算しても失敗するだろうから、計算完了するようにしておく
                        #     else:
                        #         latest_p_error = latest_p - 0.5
```
